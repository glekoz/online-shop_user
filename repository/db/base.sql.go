// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: base.sql

package db

import (
	"context"
)

const changeEmail = `-- name: ChangeEmail :exec
UPDATE users
SET email = $1
WHERE id = $2
`

type ChangeEmailParams struct {
	Email string
	ID    string
}

// асинхронно и не обновлять, пока новая почта не будет подтверждена
func (q *Queries) ChangeEmail(ctx context.Context, arg ChangeEmailParams) error {
	_, err := q.db.Exec(ctx, changeEmail, arg.Email, arg.ID)
	return err
}

const changeName = `-- name: ChangeName :exec
UPDATE users
SET name=$1
WHERE id = $2
`

type ChangeNameParams struct {
	Name string
	ID   string
}

func (q *Queries) ChangeName(ctx context.Context, arg ChangeNameParams) error {
	_, err := q.db.Exec(ctx, changeName, arg.Name, arg.ID)
	return err
}

const changePassword = `-- name: ChangePassword :exec
UPDATE users
SET password=$1
WHERE id = $2
`

type ChangePasswordParams struct {
	Password string
	ID       string
}

// асинхронно с подтверждением через почту (ссылка на изменение пароля так же отправляется на почту, и на странице по этой ссылке можно сменить пароль)
func (q *Queries) ChangePassword(ctx context.Context, arg ChangePasswordParams) error {
	_, err := q.db.Exec(ctx, changePassword, arg.Password, arg.ID)
	return err
}

const create = `-- name: Create :exec
INSERT INTO users(id, name, email, password)
VALUES ($1, $2, $3, $4)
`

type CreateParams struct {
	ID       string
	Name     string
	Email    string
	Password string
}

func (q *Queries) Create(ctx context.Context, arg CreateParams) error {
	_, err := q.db.Exec(ctx, create,
		arg.ID,
		arg.Name,
		arg.Email,
		arg.Password,
	)
	return err
}

const deleteModer = `-- name: DeleteModer :exec
DELETE FROM moders
WHERE id = $1
`

// нужно проверять, чтобы права на модерацию не убрали у админа
func (q *Queries) DeleteModer(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteModer, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const getAdmin = `-- name: GetAdmin :one
SELECT id, iscore, isplain 
FROM admins
WHERE id = $1
`

func (q *Queries) GetAdmin(ctx context.Context, id string) (Admin, error) {
	row := q.db.QueryRow(ctx, getAdmin, id)
	var i Admin
	err := row.Scan(&i.ID, &i.Iscore, &i.Isplain)
	return i, err
}

const getModer = `-- name: GetModer :one
SELECT id 
FROM moders
WHERE id = $1
`

func (q *Queries) GetModer(ctx context.Context, id string) (string, error) {
	row := q.db.QueryRow(ctx, getModer, id)
	err := row.Scan(&id)
	return id, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, name, email, password 
FROM users
WHERE email LIKE $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Password,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, name, email, password 
FROM users
WHERE id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Password,
	)
	return i, err
}

const promoteAdmin = `-- name: PromoteAdmin :exec
INSERT INTO admins(id, isCore, isPlain)
VALUES($1, $2, $3)
`

type PromoteAdminParams struct {
	ID      string
	Iscore  bool
	Isplain bool
}

// при назначении админом не забыть в транзакции дать права модератора
func (q *Queries) PromoteAdmin(ctx context.Context, arg PromoteAdminParams) error {
	_, err := q.db.Exec(ctx, promoteAdmin, arg.ID, arg.Iscore, arg.Isplain)
	return err
}

const promoteModer = `-- name: PromoteModer :exec
INSERT INTO moders(id)
VALUES($1)
`

func (q *Queries) PromoteModer(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, promoteModer, id)
	return err
}
