// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: base.sql

package db

import (
	"context"
)

const changeEmail = `-- name: ChangeEmail :execrows
UPDATE users
SET email = $1
WHERE id = $2
`

type ChangeEmailParams struct {
	Email string
	ID    string
}

// асинхронно и не обновлять, пока новая почта не будет подтверждена
func (q *Queries) ChangeEmail(ctx context.Context, arg ChangeEmailParams) (int64, error) {
	result, err := q.db.Exec(ctx, changeEmail, arg.Email, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const changeName = `-- name: ChangeName :execrows
UPDATE users
SET name = $1
WHERE id = $2
`

type ChangeNameParams struct {
	Name string
	ID   string
}

// впоследствии этот метод надо расширить на день рождения и адрес
func (q *Queries) ChangeName(ctx context.Context, arg ChangeNameParams) (int64, error) {
	result, err := q.db.Exec(ctx, changeName, arg.Name, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const changePassword = `-- name: ChangePassword :execrows
UPDATE users
SET password=$1
WHERE id = $2
`

type ChangePasswordParams struct {
	Password string
	ID       string
}

// асинхронно с подтверждением через почту (ссылка на изменение пароля так же отправляется на почту, и на странице по этой ссылке можно сменить пароль)
func (q *Queries) ChangePassword(ctx context.Context, arg ChangePasswordParams) (int64, error) {
	result, err := q.db.Exec(ctx, changePassword, arg.Password, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const confirmEmail = `-- name: ConfirmEmail :execrows
UPDATE users
SET email_confirmed = TRUE
WHERE id = $1
`

func (q *Queries) ConfirmEmail(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, confirmEmail, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const createUser = `-- name: CreateUser :exec
INSERT INTO users(id, name, email, password)
VALUES ($1, $2, $3, $4)
`

type CreateUserParams struct {
	ID       string
	Name     string
	Email    string
	Password string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.Exec(ctx, createUser,
		arg.ID,
		arg.Name,
		arg.Email,
		arg.Password,
	)
	return err
}

const deleteAdmin = `-- name: DeleteAdmin :execrows
DELETE FROM admins
WHERE id = $1
`

// нужно проверять, чтобы было isCore
func (q *Queries) DeleteAdmin(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteAdmin, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteModer = `-- name: DeleteModer :execrows
DELETE FROM moders
WHERE id = $1
`

// нужно проверять, чтобы права на модерацию не убрали у админа
func (q *Queries) DeleteModer(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteModer, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteUser = `-- name: DeleteUser :execrows
DELETE FROM users
WHERE id = $1
`

// нужно проверять, чтобы было право администратора
func (q *Queries) DeleteUser(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteUser, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getAdmin = `-- name: GetAdmin :one
SELECT id, is_core 
FROM admins
WHERE id = $1
`

func (q *Queries) GetAdmin(ctx context.Context, id string) (Admin, error) {
	row := q.db.QueryRow(ctx, getAdmin, id)
	var i Admin
	err := row.Scan(&i.ID, &i.IsCore)
	return i, err
}

const getModer = `-- name: GetModer :one
SELECT id 
FROM moders
WHERE id = $1
`

func (q *Queries) GetModer(ctx context.Context, id string) (string, error) {
	row := q.db.QueryRow(ctx, getModer, id)
	err := row.Scan(&id)
	return id, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT users.id, users.name, users.password,
    CASE WHEN moders.id IS NOT NULL THEN TRUE ELSE FALSE END AS is_moder, 
    CASE WHEN admins.id IS NOT NULL THEN TRUE ELSE FALSE END AS is_admin,
    CASE WHEN admins.iscore IS NOT NULL THEN admins.iscore ELSE FALSE END AS is_core
FROM users
    LEFT JOIN moders ON users.id = moders.id
    LEFT JOIN admins ON users.id = admins.id
WHERE users.email = $1
`

type GetUserByEmailRow struct {
	ID       string
	Name     string
	Password string
	IsModer  bool
	IsAdmin  bool
	IsCore   bool
}

// используется при логине (инфа добавляется в токен), поэтому
// нужна дополнительная информация о правах (модер, админ, isCore),
// чтобы при каждом GET запросе не идти в БД
func (q *Queries) GetUserByEmail(ctx context.Context, email string) (GetUserByEmailRow, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Password,
		&i.IsModer,
		&i.IsAdmin,
		&i.IsCore,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, name, email, password, email_confirmed 
FROM users
WHERE id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.EmailConfirmed,
	)
	return i, err
}

const getUsersByEmail = `-- name: GetUsersByEmail :many
SELECT users.id, users.name, users.email, users.email_confirmed,
	CASE WHEN moders.id IS NOT NULL THEN TRUE ELSE FALSE END AS is_moder, 
	CASE WHEN admins.id IS NOT NULL THEN TRUE ELSE FALSE END AS is_admin,
	CASE WHEN admins.iscore IS NOT NULL THEN admins.iscore ELSE FALSE END AS is_core
FROM users 
	LEFT JOIN moders ON users.id = moders.id
	LEFT JOIN admins ON users.id = admins.id
WHERE users.email LIKE $1
`

type GetUsersByEmailRow struct {
	ID             string
	Name           string
	Email          string
	EmailConfirmed bool
	IsModer        bool
	IsAdmin        bool
	IsCore         bool
}

// этот метод вызывается только администратором,
// поэтому нужна полная инфоормация о правах (модератор, админ, isCore),
// чтобы отобразить её в интерфейсе управления пользователями
func (q *Queries) GetUsersByEmail(ctx context.Context, email string) ([]GetUsersByEmailRow, error) {
	rows, err := q.db.Query(ctx, getUsersByEmail, email)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersByEmailRow
	for rows.Next() {
		var i GetUsersByEmailRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.EmailConfirmed,
			&i.IsModer,
			&i.IsAdmin,
			&i.IsCore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const promoteAdmin = `-- name: PromoteAdmin :exec
INSERT INTO admins(id, isCore)
VALUES($1, FALSE)
`

// при назначении админом не забыть в транзакции дать права модератора
func (q *Queries) PromoteAdmin(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, promoteAdmin, id)
	return err
}

const promoteCoreAdmin = `-- name: PromoteCoreAdmin :execrows
UPDATE admins
SET isCore = TRUE
WHERE id = $1
`

func (q *Queries) PromoteCoreAdmin(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, promoteCoreAdmin, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const promoteModer = `-- name: PromoteModer :exec
INSERT INTO moders(id)
VALUES($1)
`

func (q *Queries) PromoteModer(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, promoteModer, id)
	return err
}
